<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Weather Model Forecast</title>
    <link rel="stylesheet" href="https://unpkg.com/leaflet@1.9.4/dist/leaflet.css" 
          integrity="sha256-p4NxAoJBhIIN+hmNHrzRCf9tD/miZyoHS5obTRR9BMY=" 
          crossorigin=""/>
    <script src="https://unpkg.com/leaflet@1.9.4/dist/leaflet.js"
            integrity="sha256-20nQCchB9co0qIjJZRGuk2/Z9VM+kNiyxNV1lvTlZBo="
            crossorigin=""></script>
    <script src="https://cdn.jsdelivr.net/npm/chart.js"></script>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, Oxygen, Ubuntu, Cantarell, sans-serif;
            background: #0f0f0f;
            color: #e0e0e0;
            min-height: 100vh;
            padding: 20px;
        }

        .container {
            max-width: 1200px;
            margin: 0 auto;
        }

        .header {
            background: #1a1a1a;
            padding: 30px;
            border-radius: 12px;
            margin-bottom: 20px;
            border: 1px solid #2a2a2a;
        }

        h1 {
            font-size: 28px;
            margin-bottom: 20px;
            color: #fff;
        }

        .input-group {
            display: grid;
            grid-template-columns: 1fr 1fr;
            gap: 15px;
            margin-bottom: 20px;
        }

        input {
            padding: 12px 16px;
            background: #252525;
            border: 2px solid #333;
            border-radius: 8px;
            color: #e0e0e0;
            font-size: 16px;
        }

        input:focus {
            outline: none;
            border-color: #4a90e2;
        }

        .model-selector {
            display: flex;
            gap: 10px;
            flex-wrap: wrap;
        }

        .model-btn {
            padding: 12px 24px;
            border: 2px solid #333;
            background: #1a1a1a;
            color: #e0e0e0;
            border-radius: 8px;
            cursor: pointer;
            font-size: 15px;
            font-weight: 500;
            transition: all 0.2s;
        }

        .model-btn:hover {
            border-color: #555;
            background: #252525;
        }

        .model-btn.active {
            background: #4a90e2;
            border-color: #4a90e2;
            color: #fff;
        }

        .get-forecast-btn {
            padding: 12px 32px;
            background: #4a90e2;
            border: none;
            border-radius: 8px;
            color: #fff;
            font-size: 16px;
            font-weight: 600;
            cursor: pointer;
            transition: all 0.2s;
        }

        .get-forecast-btn:hover {
            background: #3d7bc7;
        }

        .get-forecast-btn:disabled {
            background: #333;
            cursor: not-allowed;
        }

        .preset-locations {
            display: flex;
            gap: 10px;
            flex-wrap: wrap;
            margin-top: 15px;
        }

        .preset-btn {
            padding: 8px 16px;
            background: #252525;
            border: 1px solid #333;
            border-radius: 6px;
            color: #999;
            cursor: pointer;
            font-size: 13px;
        }

        .preset-btn:hover {
            border-color: #555;
            color: #e0e0e0;
        }

        .forecast-section {
            display: none;
        }

        .forecast-section.active {
            display: block;
        }

        .current-weather {
            background: #1a1a1a;
            padding: 30px;
            border-radius: 12px;
            margin-bottom: 20px;
            border: 1px solid #2a2a2a;
        }

        .location-header {
            margin-bottom: 20px;
        }

        .location-name {
            font-size: 24px;
            color: #fff;
            margin-bottom: 5px;
        }

        .model-name {
            color: #4a90e2;
            font-size: 14px;
        }

        .current-grid {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(200px, 1fr));
            gap: 20px;
        }

        .current-item {
            background: #252525;
            padding: 20px;
            border-radius: 8px;
        }

        .current-label {
            font-size: 13px;
            color: #999;
            margin-bottom: 8px;
        }

        .current-value {
            font-size: 32px;
            font-weight: 700;
            color: #fff;
        }

        .current-value.temp {
            color: #4a90e2;
        }

        .current-value.wind {
            color: #f39c12;
        }

        .current-value.precip {
            color: #5ebd5e;
        }

        .charts-container {
            display: grid;
            grid-template-columns: 1fr;
            gap: 20px;
        }

        .chart-card {
            background: #1a1a1a;
            padding: 25px;
            border-radius: 12px;
            border: 1px solid #2a2a2a;
        }

        .chart-title {
            font-size: 18px;
            margin-bottom: 20px;
            color: #fff;
        }

        .chart-wrapper {
            height: 300px;
            position: relative;
        }

        .loading {
            text-align: center;
            padding: 40px;
            color: #999;
        }

        .error {
            background: #3d2020;
            color: #ff6b6b;
            padding: 20px;
            border-radius: 8px;
            margin-bottom: 20px;
            display: none;
        }

        .error.active {
            display: block;
        }

        .hourly-forecast {
            margin-bottom: 20px;
        }

        .daily-forecast {
            margin-bottom: 20px;
        }

        .radar-section {
            margin-bottom: 20px;
        }

        .goes-section {
            margin-bottom: 20px;
        }

        .historical-section {
            margin-bottom: 20px;
        }

        .layer-btn {
            padding: 8px 16px;
            background: #252525;
            border: 2px solid #333;
            border-radius: 6px;
            color: #e0e0e0;
            cursor: pointer;
            font-size: 14px;
            transition: all 0.2s;
        }

        .layer-btn:hover {
            border-color: #555;
            background: #2a2a2a;
        }

        .layer-btn.active {
            background: #4a90e2;
            border-color: #4a90e2;
            color: #fff;
        }

        #radarMap {
            z-index: 1;
        }

        .daily-cards {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(200px, 1fr));
            gap: 12px;
        }

        .daily-card {
            background: #1a1a1a;
            border: 1px solid #2a2a2a;
            border-radius: 10px;
            padding: 15px;
        }

        .daily-title {
            font-size: 16px;
            font-weight: 600;
            color: #4a90e2;
            margin-bottom: 12px;
            border-bottom: 2px solid #2a2a2a;
            padding-bottom: 8px;
        }

        .daily-content {
            font-size: 13px;
            line-height: 1.6;
        }

        .daily-stat {
            display: flex;
            justify-content: space-between;
            margin-bottom: 6px;
        }

        .daily-label {
            color: #999;
        }

        .daily-value {
            font-weight: 600;
            color: #e0e0e0;
        }

        .daily-value.temp {
            color: #4a90e2;
        }

        .daily-value.wind {
            color: #f39c12;
        }

        .daily-value.rain {
            color: #3498db;
        }

        .daily-value.snow {
            color: #9b59b6;
        }

        .hourly-forecast {
            margin-top: 20px;
        }

        .hourly-table {
            width: 100%;
            border-collapse: collapse;
            font-size: 14px;
        }

        .hourly-table th {
            background: #252525;
            padding: 12px 8px;
            text-align: left;
            color: #999;
            font-weight: 600;
            position: sticky;
            top: 0;
            z-index: 10;
        }

        .hourly-table td {
            padding: 10px 8px;
            border-bottom: 1px solid #2a2a2a;
        }

        .hourly-table tr:hover {
            background: #1f1f1f;
        }

        .temp-cell {
            color: #4a90e2;
            font-weight: 600;
        }

        .precip-cell {
            color: #5ebd5e;
        }

        .wind-cell {
            color: #f39c12;
        }

        .rain-cell {
            color: #3498db;
        }

        .snow-cell {
            color: #9b59b6;
        }

        .model-badge {
            display: inline-block;
            padding: 2px 8px;
            border-radius: 4px;
            font-size: 11px;
            font-weight: 600;
            margin-left: 8px;
        }

        .model-badge.hrrr {
            background: #10b981;
            color: #fff;
        }

        .model-badge.standard {
            background: #6366f1;
            color: #fff;
        }

        @media (max-width: 768px) {
            .input-group {
                grid-template-columns: 1fr;
            }
            
            .current-grid {
                grid-template-columns: 1fr;
            }
        }
    </style>
<link rel="manifest" href="/manifest.json">
<meta name="theme-color" content="#1e40af">
</head>
<body>
    <div class="container">
        <div class="header">
            <h1>Weather Model Forecast</h1>
            
            <div class="input-group">
                <input type="text" id="cityInput" placeholder="Enter city name (e.g., Orlando, FL)" style="grid-column: 1 / -1;" onkeypress="if(event.key==='Enter') searchCity()">
                <button class="get-forecast-btn" onclick="searchCity()">Search City</button>
                <button class="get-forecast-btn" onclick="getCurrentLocation()" style="background: #5ebd5e;">Use Current Location</button>
            </div>

            <div class="preset-locations">
                <button class="preset-btn" onclick="setLocation(28.2189, -82.4526)">Land O' Lakes, FL</button>
                <button class="preset-btn" onclick="setLocation(41.2565, -74.3587)">Warwick, NY</button>
                <button class="preset-btn" onclick="setLocation(45.5017, -73.5673)">Montreal, QC</button>
                <button class="preset-btn" onclick="setLocation(46.8139, -71.2080)">Quebec City, QC</button>
                <button class="preset-btn" onclick="setLocation(28.5383, -81.3792)">Orlando, FL</button>
            </div>

            <div class="model-selector">
                <button class="model-btn active" data-model="hrrr" onclick="selectModel('hrrr')">HRRR (High Res)</button>
                <button class="model-btn" data-model="gfs" onclick="selectModel('gfs')">GFS</button>
                <button class="model-btn" data-model="nam" onclick="selectModel('nam')">NAM (US)</button>
                <button class="model-btn" data-model="ecmwf" onclick="selectModel('ecmwf')">ECMWF</button>
                <button class="model-btn" data-model="blend" onclick="selectModel('blend')">Smart Blend</button>
            </div>
        </div>

        <div class="error" id="error"></div>

        <div class="loading" id="loading" style="display: none;">
            Loading forecast data...
        </div>

        <div class="forecast-section" id="forecast">
            <div class="current-weather">
                <div class="location-header">
                    <div class="location-name" id="locationName">--</div>
                    <div class="model-name" id="modelName">--</div>
                    <div class="model-name" id="modelRun" style="color: #999; font-size: 12px; margin-top: 5px;">--</div>
                </div>

                <div class="current-grid">
                    <div class="current-item">
                        <div class="current-label">Temperature</div>
                        <div class="current-value temp" id="temp">--°F</div>
                    </div>
                    <div class="current-item">
                        <div class="current-label">Feels Like</div>
                        <div class="current-value temp" id="feelsLike">--°F</div>
                    </div>
                    <div class="current-item">
                        <div class="current-label">Wind Speed</div>
                        <div class="current-value wind" id="wind">-- mph</div>
                    </div>
                    <div class="current-item">
                        <div class="current-label">Humidity</div>
                        <div class="current-value" id="humidity">--%</div>
                    </div>
                    <div class="current-item">
                        <div class="current-label">Precipitation</div>
                        <div class="current-value precip" id="precip">-- in</div>
                    </div>
                    <div class="current-item">
                        <div class="current-label">Pressure</div>
                        <div class="current-value" id="pressure">-- mb</div>
                    </div>
                    <div class="current-item">
                        <div class="current-label">Conditions</div>
                        <div class="current-value" style="font-size: 18px;" id="conditions">--</div>
                    </div>
                </div>
            </div>

            <div class="daily-forecast">
                <div class="daily-cards">
                    <div class="daily-card">
                        <div class="daily-title">Today</div>
                        <div class="daily-content" id="todayForecast">--</div>
                    </div>
                    <div class="daily-card">
                        <div class="daily-title">Tomorrow</div>
                        <div class="daily-content" id="tomorrowForecast">--</div>
                    </div>
                    <div class="daily-card">
                        <div class="daily-title">Day After</div>
                        <div class="daily-content" id="dayAfterForecast">--</div>
                    </div>
                </div>
            </div>

            <div class="charts-container">
                <div class="chart-card">
                    <div style="display: flex; justify-content: space-between; align-items: center; margin-bottom: 20px;">
                        <div class="chart-title" style="margin: 0;">Temperature & Feels Like Forecast</div>
                        <select id="timeRange" onchange="updateCharts()" style="padding: 8px 12px; background: #252525; border: 1px solid #333; border-radius: 6px; color: #e0e0e0; font-size: 14px;">
                            <option value="24">24 Hours</option>
                            <option value="48" selected>48 Hours</option>
                            <option value="72">72 Hours</option>
                            <option value="96">96 Hours</option>
                            <option value="120">120 Hours</option>
                            <option value="136">136 Hours (GFS Only)</option>
                        </select>
                    </div>
                    <div class="chart-wrapper">
                        <canvas id="tempChart"></canvas>
                    </div>
                </div>

                <div class="chart-card">
                    <div class="chart-title">Precipitation Probability & Type</div>
                    <div class="chart-wrapper">
                        <canvas id="precipChart"></canvas>
                    </div>
                </div>

                <div class="chart-card">
                    <div class="chart-title">Precipitation Accumulation</div>
                    <div id="precipTotals" style="font-size: 14px; color: #999; margin-bottom: 15px;">--</div>
                    <div class="chart-wrapper">
                        <canvas id="precipAccumChart"></canvas>
                    </div>
                </div>

                <div class="chart-card">
                    <div class="chart-title">Wind Speed Forecast</div>
                    <div class="chart-wrapper">
                        <canvas id="windChart"></canvas>
                    </div>
                </div>
            </div>

            <div class="historical-section">
                <div class="chart-card">
                    <div class="chart-title">Historical Weather (Past 24 Hours)</div>
                    <div class="chart-wrapper">
                        <canvas id="historicalChart"></canvas>
                    </div>
                </div>
            </div>

            <div class="hourly-forecast">
                <div class="chart-card">
                    <div class="chart-title">Hourly Forecast</div>
                    <div id="hourlyTable" style="overflow-x: auto;"></div>
                </div>
            </div>

            <div class="radar-section">
                <div class="chart-card">
                    <div class="chart-title">Precipitation Radar</div>
                    <div id="radarContainer" style="height: 500px; position: relative; background: #0a0a0a; border-radius: 8px; overflow: hidden;">
                        <div id="radarMap" style="height: 100%; width: 100%;"></div>
                        <div id="radarTimeline" style="position: absolute; bottom: 20px; left: 10px; right: 10px; background: rgba(26, 26, 26, 0.9); padding: 15px; border-radius: 8px; z-index: 1000;">
                            <div style="display: flex; align-items: center; gap: 10px; margin-bottom: 10px;">
                                <button onclick="playRadarAnimation()" id="playBtn" style="padding: 8px 16px; background: #4a90e2; border: none; border-radius: 6px; color: #fff; cursor: pointer;">Play</button>
                                <button onclick="pauseRadarAnimation()" id="pauseBtn" style="padding: 8px 16px; background: #666; border: none; border-radius: 6px; color: #fff; cursor: pointer;">Pause</button>
                                <span id="radarTimeDisplay" style="color: #e0e0e0; font-size: 14px;">--</span>
                            </div>
                            <input type="range" id="radarSlider" min="0" max="0" value="0" style="width: 100%;" oninput="updateRadarFrame(this.value)">
                        </div>
                    </div>
                </div>
            </div>
        </div>
    </div>

    <script>
        let currentModel = 'hrrr'; // Default to HRRR-subhourly for best accuracy
        let tempChart = null;
        let precipChart = null;
        let precipAccumChart = null;
        let windChart = null;
        let historicalChart = null;
        let currentForecastData = null;
        let radarMap = null;
        let radarMarker = null;
        let radarLayer = null;
        let goesMap = null;
        let goesMarker = null;
        let goesLayer = null;
        let radarFrames = [];
        let radarAnimationTimer = null;
        let currentFrameIndex = 0;

        function selectModel(model) {
            currentModel = model;
            document.querySelectorAll('.model-btn').forEach(btn => {
                btn.classList.remove('active');
            });
            document.querySelector(`[data-model="${model}"]`).classList.add('active');
        }

        function setLocation(lat, lng) {
            getForecast(lat, lng);
        }

        async function searchCity() {
            const cityName = document.getElementById('cityInput').value.trim();
            
            if (!cityName) {
                showError('Please enter a city name');
                return;
            }

            try {
                const response = await fetch(`https://nominatim.openstreetmap.org/search?q=${encodeURIComponent(cityName)}&format=json&limit=1`);
                const data = await response.json();

                if (data.length === 0) {
                    showError('City not found. Try including state/country (e.g., "Orlando, FL" or "Paris, France")');
                    return;
                }

                const lat = parseFloat(data[0].lat);
                const lng = parseFloat(data[0].lon);

                getForecast(lat, lng);
            } catch (err) {
                showError(`Error searching for city: ${err.message}`);
            }
        }

        function getCurrentLocation() {
            if (!navigator.geolocation) {
                showError('Geolocation is not supported by your browser');
                return;
            }

            document.getElementById('loading').style.display = 'block';
            
            navigator.geolocation.getCurrentPosition(
                (position) => {
                    const lat = position.coords.latitude;
                    const lng = position.coords.longitude;
                    getForecast(lat, lng);
                },
                (error) => {
                    document.getElementById('loading').style.display = 'none';
                    showError('Unable to get your location. Please enable location services or enter a city name.');
                }
            );
        }

        async function getForecast(lat, lng) {
            if (isNaN(lat) || isNaN(lng)) {
                showError('Please enter valid latitude and longitude values');
                return;
            }

            if (lat < -90 || lat > 90 || lng < -180 || lng > 180) {
                showError('Latitude must be between -90 and 90, longitude between -180 and 180');
                return;
            }

            document.getElementById('loading').style.display = 'block';
            document.getElementById('forecast').classList.remove('active');
            document.getElementById('error').classList.remove('active');

            if (currentModel === 'blend') {
                await fetchSmartBlend(lat, lng);
            } else if (currentModel === 'hrrr') {
                await fetchHRRRSubhourly(lat, lng);
            } else {
                await fetchSingleModel(lat, lng);
            }
        }

        // HRRR function for high-resolution short-term forecasts (3km, hourly updates, 48hr forecast)
        async function fetchHRRRSubhourly(lat, lng) {
            try {
                // Check if location is in US (HRRR coverage)
                const isUS = (lat >= 20 && lat <= 55 && lng >= -130 && lng <= -60);
                
                if (!isUS) {
                    showError('HRRR is only available for US locations. Switching to ECMWF...');
                    currentModel = 'ecmwf';
                    selectModel('ecmwf');
                    await fetchSingleModel(lat, lng);
                    return;
                }

                const apiUrl = 'https://api.open-meteo.com/v1/forecast';
                
                // Fetch HRRR for 0-48 hours (3km resolution, hourly)
                const hrrrUrl = `${apiUrl}?latitude=${lat}&longitude=${lng}&current=temperature_2m,apparent_temperature,relative_humidity_2m,precipitation,weather_code,wind_speed_10m,surface_pressure&hourly=temperature_2m,apparent_temperature,precipitation_probability,precipitation,rain,snowfall,wind_speed_10m&temperature_unit=fahrenheit&wind_speed_unit=mph&precipitation_unit=inch&timezone=auto&forecast_days=2&models=best_match`;
                
                // Also fetch GFS for extended forecast (48+ hours)
                const gfsUrl = `${apiUrl}?latitude=${lat}&longitude=${lng}&hourly=temperature_2m,apparent_temperature,precipitation_probability,precipitation,rain,showers,snowfall,wind_speed_10m&temperature_unit=fahrenheit&wind_speed_unit=mph&precipitation_unit=inch&timezone=auto&forecast_days=7&models=gfs_seamless`;
                
                const [hrrrResponse, gfsResponse] = await Promise.all([
                    fetch(hrrrUrl),
                    fetch(gfsUrl)
                ]);
                
                if (!hrrrResponse.ok || !gfsResponse.ok) {
                    throw new Error('Failed to fetch HRRR or GFS data');
                }
                
                const hrrrData = await hrrrResponse.json();
                const gfsData = await gfsResponse.json();
                
                console.log('HRRR data:', hrrrData);
                console.log('GFS extended data:', gfsData);

                // Get location name
                try {
                    const geoResponse = await fetch(`https://nominatim.openstreetmap.org/reverse?lat=${lat}&lon=${lng}&format=json`);
                    const geoData = await geoResponse.json();
                    const locationName = geoData.address?.city || geoData.address?.town || geoData.address?.county || 'Unknown Location';
                    document.getElementById('locationName').textContent = `${locationName} (${lat.toFixed(4)}°, ${lng.toFixed(4)}°)`;
                } catch (e) {
                    document.getElementById('locationName').textContent = `${lat.toFixed(4)}°, ${lng.toFixed(4)}°`;
                }

                document.getElementById('modelName').textContent = 'HRRR (3km, Hourly) + GFS Extended';
                
                if (hrrrData.current && hrrrData.current.time) {
                    const runTime = new Date(hrrrData.current.time);
                    document.getElementById('modelRun').textContent = `HRRR updated: ${runTime.toLocaleString('en-US', { 
                        month: 'short', 
                        day: 'numeric', 
                        hour: 'numeric', 
                        minute: '2-digit',
                        timeZoneName: 'short'
                    })} | 3km resolution, updates hourly`;
                }

                // Use HRRR current conditions (most accurate)
                document.getElementById('temp').textContent = `${Math.round(hrrrData.current.temperature_2m)}°F`;
                document.getElementById('feelsLike').textContent = hrrrData.current.apparent_temperature ? `${Math.round(hrrrData.current.apparent_temperature)}°F` : 'N/A';
                document.getElementById('wind').textContent = `${Math.round(hrrrData.current.wind_speed_10m)} mph`;
                document.getElementById('humidity').textContent = `${hrrrData.current.relative_humidity_2m}%`;
                document.getElementById('precip').textContent = hrrrData.current.precipitation !== null ? `${hrrrData.current.precipitation.toFixed(2)} in` : '0.00 in';
                document.getElementById('pressure').textContent = hrrrData.current.surface_pressure ? `${Math.round(hrrrData.current.surface_pressure)} mb` : 'N/A';
                document.getElementById('conditions').textContent = getWeatherDescription(hrrrData.current.weather_code);

                // Merge HRRR (first 48 hours) with GFS (48+ hours)
                const mergedHourly = mergeForecasts(hrrrData.hourly, gfsData.hourly, 48);
                
                currentForecastData = mergedHourly;

                // Fetch historical data
                const yesterday = new Date();
                yesterday.setDate(yesterday.getDate() - 1);
                const today = new Date();
                const startDate = yesterday.toISOString().split('T')[0];
                const endDate = today.toISOString().split('T')[0];
                
                const historicalUrl = `https://archive-api.open-meteo.com/v1/archive?latitude=${lat}&longitude=${lng}&start_date=${startDate}&end_date=${endDate}&hourly=temperature_2m,precipitation,rain,snowfall,wind_speed_10m&temperature_unit=fahrenheit&wind_speed_unit=mph&precipitation_unit=inch&timezone=auto`;
                const historicalResponse = await fetch(historicalUrl);
                const historicalData = historicalResponse.ok ? await historicalResponse.json() : null;

                updateCharts(historicalData);
                initRadar(lat, lng);

                document.getElementById('loading').style.display = 'none';
                document.getElementById('forecast').classList.add('active');

            } catch (err) {
                document.getElementById('loading').style.display = 'none';
                showError(`Error loading HRRR data: ${err.message}`);
            }
        }

        // Merge short-term accurate forecast with longer-term forecast
        function mergeForecasts(shortTerm, longTerm, cutoffHours) {
            const merged = {
                time: [],
                temperature_2m: [],
                apparent_temperature: [],
                precipitation_probability: [],
                precipitation: [],
                rain: [],
                snowfall: [],
                wind_speed_10m: []
            };

            // Use short-term data for first cutoffHours
            const shortTermLength = Math.min(shortTerm.time.length, cutoffHours);
            for (let i = 0; i < shortTermLength; i++) {
                merged.time.push(shortTerm.time[i]);
                merged.temperature_2m.push(shortTerm.temperature_2m[i]);
                merged.apparent_temperature.push(shortTerm.apparent_temperature?.[i] || shortTerm.temperature_2m[i]);
                merged.precipitation_probability.push(0); // HRRR doesn't have prob
                merged.precipitation.push(shortTerm.precipitation?.[i] || 0);
                merged.rain.push(shortTerm.rain?.[i] || 0);
                merged.snowfall.push(shortTerm.snowfall?.[i] || 0);
                merged.wind_speed_10m.push(shortTerm.wind_speed_10m[i]);
            }

            // Append long-term data after cutoff
            const cutoffTime = new Date(shortTerm.time[shortTermLength - 1]);
            for (let i = 0; i < longTerm.time.length; i++) {
                const currentTime = new Date(longTerm.time[i]);
                if (currentTime > cutoffTime) {
                    merged.time.push(longTerm.time[i]);
                    merged.temperature_2m.push(longTerm.temperature_2m[i]);
                    merged.apparent_temperature.push(longTerm.apparent_temperature?.[i] || longTerm.temperature_2m[i]);
                    merged.precipitation_probability.push(longTerm.precipitation_probability?.[i] || 0);
                    merged.precipitation.push(longTerm.precipitation?.[i] || 0);
                    merged.rain.push(longTerm.rain?.[i] || 0);
                    merged.snowfall.push(longTerm.snowfall?.[i] || 0);
                    merged.wind_speed_10m.push(longTerm.wind_speed_10m[i]);
                }
            }

            return merged;
        }

        // Smart Blend: Uses HRRR for 0-48h, then blends NAM/GFS/ECMWF for 48+
        async function fetchSmartBlend(lat, lng) {
            try {
                const apiUrl = 'https://api.open-meteo.com/v1/forecast';
                const isUS = (lat >= 20 && lat <= 55 && lng >= -130 && lng <= -60);
                
                let modelsToFetch = [];
                let modelNames = [];
                
                // For US: Use HRRR for short term (best_match gives HRRR in US)
                if (isUS) {
                    modelsToFetch.push(
                        fetch(`${apiUrl}?latitude=${lat}&longitude=${lng}&current=temperature_2m,apparent_temperature,relative_humidity_2m,precipitation,weather_code,wind_speed_10m,surface_pressure&hourly=temperature_2m,apparent_temperature,precipitation_probability,precipitation,rain,snowfall,wind_speed_10m&temperature_unit=fahrenheit&wind_speed_unit=mph&precipitation_unit=inch&timezone=auto&forecast_days=2&models=best_match`)
                    );
                    modelNames.push('HRRR');
                }
                
                // Always fetch GFS and ECMWF for medium/long range
                modelsToFetch.push(
                    fetch(`${apiUrl}?latitude=${lat}&longitude=${lng}&current=temperature_2m,apparent_temperature,relative_humidity_2m,precipitation,weather_code,wind_speed_10m,surface_pressure&hourly=temperature_2m,apparent_temperature,precipitation_probability,precipitation,rain,showers,snowfall,wind_speed_10m&temperature_unit=fahrenheit&wind_speed_unit=mph&precipitation_unit=inch&timezone=auto&forecast_days=7&models=gfs_seamless`),
                    fetch(`${apiUrl}?latitude=${lat}&longitude=${lng}&current=temperature_2m,apparent_temperature,relative_humidity_2m,precipitation,weather_code,wind_speed_10m,surface_pressure&hourly=temperature_2m,apparent_temperature,precipitation_probability,precipitation,rain,showers,snowfall,wind_speed_10m&temperature_unit=fahrenheit&wind_speed_unit=mph&precipitation_unit=inch&timezone=auto&forecast_days=10&models=ecmwf_ifs025`)
                );
                modelNames.push('GFS', 'ECMWF');
                
                const responses = await Promise.all(modelsToFetch);
                const modelData = await Promise.all(responses.map(r => r.json()));
                
                console.log('Smart Blend models:', modelNames);

                // Get location
                try {
                    const geoResponse = await fetch(`https://nominatim.openstreetmap.org/reverse?lat=${lat}&lon=${lng}&format=json`);
                    const geoData = await geoResponse.json();
                    const locationName = geoData.address?.city || geoData.address?.town || geoData.address?.county || 'Unknown Location';
                    document.getElementById('locationName').textContent = `${locationName} (${lat.toFixed(4)}°, ${lng.toFixed(4)}°)`;
                } catch (e) {
                    document.getElementById('locationName').textContent = `${lat.toFixed(4)}°, ${lng.toFixed(4)}°`;
                }

                document.getElementById('modelName').textContent = `Smart Blend (${modelNames.join(' + ')})`;
                
                if (modelData[0].current) {
                    const runTime = new Date(modelData[0].current.time);
                    document.getElementById('modelRun').textContent = `Latest: ${runTime.toLocaleString('en-US', { 
                        month: 'short', 
                        day: 'numeric', 
                        hour: 'numeric', 
                        minute: '2-digit',
                        timeZoneName: 'short'
                    })}`;
                }

                // Use HRRR current if available, else blend
                const currentSource = isUS ? modelData[0] : modelData[0];
                document.getElementById('temp').textContent = `${Math.round(currentSource.current.temperature_2m)}°F`;
                document.getElementById('feelsLike').textContent = `${Math.round(currentSource.current.apparent_temperature || currentSource.current.temperature_2m)}°F`;
                document.getElementById('wind').textContent = `${Math.round(currentSource.current.wind_speed_10m)} mph`;
                document.getElementById('humidity').textContent = `${currentSource.current.relative_humidity_2m}%`;
                document.getElementById('precip').textContent = `${(currentSource.current.precipitation || 0).toFixed(2)} in`;
                document.getElementById('pressure').textContent = `${Math.round(currentSource.current.surface_pressure || 0)} mb`;
                document.getElementById('conditions').textContent = getWeatherDescription(currentSource.current.weather_code);

                // Smart blending logic
                let blendedHourly;
                
                if (isUS) {
                    // Use HRRR for short term, blend others for longer
                    const hrrrData = modelData[0];
                    const longerModels = modelData.slice(1);
                    
                    // Blend the longer models for 48+ hours
                    const maxHours = Math.min(...longerModels.map(d => d.hourly.time.length));
                    const blendedLonger = {
                        time: longerModels[0].hourly.time.slice(0, maxHours),
                        temperature_2m: [],
                        apparent_temperature: [],
                        precipitation_probability: [],
                        precipitation: [],
                        rain: [],
                        snowfall: [],
                        wind_speed_10m: []
                    };

                    for (let i = 0; i < maxHours; i++) {
                        blendedLonger.temperature_2m[i] = longerModels.reduce((sum, d) => sum + d.hourly.temperature_2m[i], 0) / longerModels.length;
                        blendedLonger.apparent_temperature[i] = longerModels.reduce((sum, d) => sum + (d.hourly.apparent_temperature?.[i] || blendedLonger.temperature_2m[i]), 0) / longerModels.length;
                        blendedLonger.precipitation_probability[i] = longerModels.reduce((sum, d) => sum + (d.hourly.precipitation_probability?.[i] || 0), 0) / longerModels.length;
                        blendedLonger.precipitation[i] = longerModels.reduce((sum, d) => sum + (d.hourly.precipitation?.[i] || 0), 0) / longerModels.length;
                        blendedLonger.rain[i] = longerModels.reduce((sum, d) => sum + (d.hourly.rain?.[i] || 0), 0) / longerModels.length;
                        blendedLonger.snowfall[i] = longerModels.reduce((sum, d) => sum + (d.hourly.snowfall?.[i] || 0), 0) / longerModels.length;
                        blendedLonger.wind_speed_10m[i] = longerModels.reduce((sum, d) => sum + d.hourly.wind_speed_10m[i], 0) / longerModels.length;
                    }
                    
                    // Merge HRRR with blended longer forecast
                    blendedHourly = mergeForecasts(hrrrData.hourly, blendedLonger, 48);
                } else {
                    // No HRRR, just blend all models
                    const maxHours = Math.min(...modelData.map(d => d.hourly.time.length));
                    blendedHourly = {
                        time: modelData[0].hourly.time.slice(0, maxHours),
                        temperature_2m: [],
                        apparent_temperature: [],
                        precipitation_probability: [],
                        precipitation: [],
                        rain: [],
                        snowfall: [],
                        wind_speed_10m: []
                    };

                    for (let i = 0; i < maxHours; i++) {
                        blendedHourly.temperature_2m[i] = modelData.reduce((sum, d) => sum + d.hourly.temperature_2m[i], 0) / modelData.length;
                        blendedHourly.apparent_temperature[i] = modelData.reduce((sum, d) => sum + (d.hourly.apparent_temperature?.[i] || blendedHourly.temperature_2m[i]), 0) / modelData.length;
                        blendedHourly.precipitation_probability[i] = modelData.reduce((sum, d) => sum + (d.hourly.precipitation_probability?.[i] || 0), 0) / modelData.length;
                        blendedHourly.precipitation[i] = modelData.reduce((sum, d) => sum + (d.hourly.precipitation?.[i] || 0), 0) / modelData.length;
                        blendedHourly.rain[i] = modelData.reduce((sum, d) => sum + (d.hourly.rain?.[i] || 0), 0) / modelData.length;
                        blendedHourly.snowfall[i] = modelData.reduce((sum, d) => sum + (d.hourly.snowfall?.[i] || 0), 0) / modelData.length;
                        blendedHourly.wind_speed_10m[i] = modelData.reduce((sum, d) => sum + d.hourly.wind_speed_10m[i], 0) / modelData.length;
                    }
                }

                currentForecastData = blendedHourly;

                // Historical data
                const yesterday = new Date();
                yesterday.setDate(yesterday.getDate() - 1);
                const today = new Date();
                const startDate = yesterday.toISOString().split('T')[0];
                const endDate = today.toISOString().split('T')[0];
                
                const historicalUrl = `https://archive-api.open-meteo.com/v1/archive?latitude=${lat}&longitude=${lng}&start_date=${startDate}&end_date=${endDate}&hourly=temperature_2m,precipitation,rain,snowfall,wind_speed_10m&temperature_unit=fahrenheit&wind_speed_unit=mph&precipitation_unit=inch&timezone=auto`;
                const historicalResponse = await fetch(historicalUrl);
                const historicalData = historicalResponse.ok ? await historicalResponse.json() : null;

                updateCharts(historicalData);
                initRadar(lat, lng);

                document.getElementById('loading').style.display = 'none';
                document.getElementById('forecast').classList.add('active');

            } catch (err) {
                document.getElementById('loading').style.display = 'none';
                showError(`Error loading smart blend: ${err.message}`);
            }
        }

        async function fetchSingleModel(lat, lng) {
            let modelParam = 'gfs_seamless';
            let modelDisplayName = 'GFS (Global Forecast System)';
            let forecastDays = 7;
            let apiUrl = 'https://api.open-meteo.com/v1/forecast';
            
            if (currentModel === 'nam') {
                modelParam = 'best_match';
                modelDisplayName = 'NAM (North American Mesoscale)';
                forecastDays = 3;
            } else if (currentModel === 'ecmwf') {
                modelParam = 'ecmwf_ifs025';
                modelDisplayName = 'ECMWF IFS';
                forecastDays = 10;
            }

            try {
                const url = `${apiUrl}?latitude=${lat}&longitude=${lng}&current=temperature_2m,apparent_temperature,relative_humidity_2m,precipitation,weather_code,wind_speed_10m,surface_pressure&hourly=temperature_2m,apparent_temperature,precipitation_probability,precipitation,rain,showers,snowfall,wind_speed_10m&temperature_unit=fahrenheit&wind_speed_unit=mph&precipitation_unit=inch&timezone=auto&forecast_days=${forecastDays}&models=${modelParam}`;
                
                const response = await fetch(url);
                
                if (!response.ok) {
                    const errorText = await response.text();
                    throw new Error(`API returned ${response.status}: ${errorText}`);
                }
                
                const data = await response.json();

                try {
                    const geoResponse = await fetch(`https://nominatim.openstreetmap.org/reverse?lat=${lat}&lon=${lng}&format=json`);
                    const geoData = await geoResponse.json();
                    const locationName = geoData.address?.city || geoData.address?.town || geoData.address?.county || 'Unknown Location';
                    document.getElementById('locationName').textContent = `${locationName} (${lat.toFixed(4)}°, ${lng.toFixed(4)}°)`;
                } catch (e) {
                    document.getElementById('locationName').textContent = `${lat.toFixed(4)}°, ${lng.toFixed(4)}°`;
                }

                document.getElementById('modelName').textContent = modelDisplayName;
                
                if (data.current && data.current.time) {
                    const runTime = new Date(data.current.time);
                    document.getElementById('modelRun').textContent = `Model run: ${runTime.toLocaleString('en-US', { 
                        month: 'short', 
                        day: 'numeric', 
                        hour: 'numeric', 
                        minute: '2-digit',
                        timeZoneName: 'short'
                    })}`;
                }

                document.getElementById('temp').textContent = `${Math.round(data.current.temperature_2m)}°F`;
                document.getElementById('feelsLike').textContent = data.current.apparent_temperature ? `${Math.round(data.current.apparent_temperature)}°F` : 'N/A';
                document.getElementById('wind').textContent = `${Math.round(data.current.wind_speed_10m)} mph`;
                document.getElementById('humidity').textContent = `${data.current.relative_humidity_2m}%`;
                document.getElementById('precip').textContent = data.current.precipitation !== null ? `${data.current.precipitation.toFixed(2)} in` : '0.00 in';
                document.getElementById('pressure').textContent = data.current.surface_pressure ? `${Math.round(data.current.surface_pressure)} mb` : 'N/A';
                document.getElementById('conditions').textContent = getWeatherDescription(data.current.weather_code);

                currentForecastData = data.hourly;

                const yesterday = new Date();
                yesterday.setDate(yesterday.getDate() - 1);
                const today = new Date();
                const startDate = yesterday.toISOString().split('T')[0];
                const endDate = today.toISOString().split('T')[0];
                
                const historicalUrl = `https://archive-api.open-meteo.com/v1/archive?latitude=${lat}&longitude=${lng}&start_date=${startDate}&end_date=${endDate}&hourly=temperature_2m,precipitation,rain,snowfall,wind_speed_10m&temperature_unit=fahrenheit&wind_speed_unit=mph&precipitation_unit=inch&timezone=auto`;
                const historicalResponse = await fetch(historicalUrl);
                const historicalData = historicalResponse.ok ? await historicalResponse.json() : null;

                updateCharts(historicalData);
                initRadar(lat, lng);

                document.getElementById('loading').style.display = 'none';
                document.getElementById('forecast').classList.add('active');

            } catch (err) {
                document.getElementById('loading').style.display = 'none';
                showError(`Error loading weather data: ${err.message}`);
            }
        }

        async function initRadar(lat, lng) {
            if (!radarMap) {
                radarMap = L.map('radarMap').setView([lat, lng], 7);
                
                L.tileLayer('https://{s}.basemaps.cartocdn.com/dark_all/{z}/{x}/{y}{r}.png', {
                    attribution: '&copy; OpenStreetMap, &copy; CARTO',
                    maxZoom: 19
                }).addTo(radarMap);
                
            } else {
                radarMap.setView([lat, lng], 7);
            }

            if (radarMarker) {
                radarMap.removeLayer(radarMarker);
            }
            
            radarMarker = L.marker([lat, lng]).addTo(radarMap);
            radarMarker.bindPopup('Your Location').openPopup();

            await loadRainViewerRadar();
            
            setTimeout(() => {
                radarMap.invalidateSize();
            }, 100);
        }

        async function loadRainViewerRadar() {
            try {
                const response = await fetch('https://api.rainviewer.com/public/weather-maps.json');
                const data = await response.json();
                
                radarFrames = [];
                
                if (data.radar && data.radar.past) {
                    radarFrames = data.radar.past.map(frame => ({
                        time: frame.time,
                        path: frame.path,
                        isPast: true
                    }));
                }
                
                if (data.radar && data.radar.nowcast) {
                    const forecastFrames = data.radar.nowcast.map(frame => ({
                        time: frame.time,
                        path: frame.path,
                        isPast: false
                    }));
                    radarFrames = radarFrames.concat(forecastFrames);
                }
                
                if (radarFrames.length > 0) {
                    const slider = document.getElementById('radarSlider');
                    slider.max = radarFrames.length - 1;
                    slider.value = radarFrames.length - 1;
                    currentFrameIndex = radarFrames.length - 1;
                    
                    updateRadarFrame(currentFrameIndex);
                }
                
            } catch (err) {
                console.error('Error loading RainViewer data:', err);
            }
        }

        function updateRadarFrame(frameIndex) {
            currentFrameIndex = parseInt(frameIndex);
            
            if (radarFrames.length === 0 || !radarMap) return;
            
            const frame = radarFrames[currentFrameIndex];
            
            if (radarLayer) {
                radarMap.removeLayer(radarLayer);
            }
            
            radarLayer = L.tileLayer(`https://tilecache.rainviewer.com${frame.path}/256/{z}/{x}/{y}/2/1_1.png`, {
                attribution: 'RainViewer',
                opacity: 0.7,
                maxZoom: 12
            });
            
            radarLayer.addTo(radarMap);
            
            const date = new Date(frame.time * 1000);
            const timeStr = date.toLocaleString('en-US', { 
                month: 'short', 
                day: 'numeric', 
                hour: 'numeric', 
                minute: '2-digit' 
            });
            const label = frame.isPast ? 'Past' : 'Forecast';
            document.getElementById('radarTimeDisplay').textContent = `${timeStr} (${label})`;
        }

        function playRadarAnimation() {
            if (radarAnimationTimer) return;
            
            radarAnimationTimer = setInterval(() => {
                currentFrameIndex++;
                if (currentFrameIndex >= radarFrames.length) {
                    currentFrameIndex = 0;
                }
                document.getElementById('radarSlider').value = currentFrameIndex;
                updateRadarFrame(currentFrameIndex);
            }, 500);
        }

        function pauseRadarAnimation() {
            if (radarAnimationTimer) {
                clearInterval(radarAnimationTimer);
                radarAnimationTimer = null;
            }
        }

        function updateCharts(historicalData) {
            if (!currentForecastData) return;

            const hourlyData = currentForecastData;
            const timeRange = parseInt(document.getElementById('timeRange').value);
            
            const now = new Date();
            let startIndex = 0;
            for (let i = 0; i < hourlyData.time.length; i++) {
                const hourTime = new Date(hourlyData.time[i]);
                if (hourTime >= now) {
                    startIndex = i;
                    break;
                }
            }
            
            const hours = hourlyData.time.slice(startIndex, startIndex + timeRange).map(time => {
                const date = new Date(time);
                return date.toLocaleString('en-US', { month: 'short', day: 'numeric', hour: 'numeric' });
            });

            const temps = hourlyData.temperature_2m.slice(startIndex, startIndex + timeRange);
            const feelsLike = hourlyData.apparent_temperature ? hourlyData.apparent_temperature.slice(startIndex, startIndex + timeRange) : temps;
            const precipProb = hourlyData.precipitation_probability ? hourlyData.precipitation_probability.slice(startIndex, startIndex + timeRange) : Array(timeRange).fill(0);
            const totalPrecip = hourlyData.precipitation ? hourlyData.precipitation.slice(startIndex, startIndex + timeRange) : Array(timeRange).fill(0);
            const rain = hourlyData.rain ? hourlyData.rain.slice(startIndex, startIndex + timeRange) : totalPrecip;
            const snow = hourlyData.snowfall ? hourlyData.snowfall.slice(startIndex, startIndex + timeRange) : Array(timeRange).fill(0);
            const wind = hourlyData.wind_speed_10m.slice(startIndex, startIndex + timeRange);

            const totalRain = rain.reduce((a, b) => a + (b || 0), 0);
            const totalSnow = snow.reduce((a, b) => a + (b || 0), 0);
            const totalAll = totalPrecip.reduce((a, b) => a + (b || 0), 0);
            
            document.getElementById('precipTotals').innerHTML = `
                <strong>Total Precipitation:</strong> ${totalAll.toFixed(2)}" 
                (Rain: ${totalRain.toFixed(2)}", Snow: ${totalSnow.toFixed(2)}")
            `;

            generateDailyForecasts(hourlyData, startIndex);

            if (historicalData) {
                generateHistoricalChart(historicalData);
            }

            generateHourlyTable(hours, temps, feelsLike, precipProb, totalPrecip, rain, snow, wind);

            const ctx1 = document.getElementById('tempChart').getContext('2d');
            
            if (tempChart) {
                tempChart.destroy();
            }

            tempChart = new Chart(ctx1, {
                type: 'line',
                data: {
                    labels: hours,
                    datasets: [
                        {
                            label: 'Temperature (°F)',
                            data: temps,
                            borderColor: '#4a90e2',
                            backgroundColor: 'rgba(74, 144, 226, 0.1)',
                            tension: 0.4,
                            borderWidth: 2,
                            fill: false
                        },
                        {
                            label: 'Feels Like (°F)',
                            data: feelsLike,
                            borderColor: '#e74c3c',
                            backgroundColor: 'rgba(231, 76, 60, 0.1)',
                            tension: 0.4,
                            borderWidth: 2,
                            borderDash: [5, 5],
                            fill: false
                        }
                    ]
                },
                options: {
                    responsive: true,
                    maintainAspectRatio: false,
                    interaction: {
                        mode: 'index',
                        intersect: false
                    },
                    plugins: {
                        legend: {
                            labels: {
                                color: '#e0e0e0',
                                font: { size: 12 }
                            }
                        }
                    },
                    scales: {
                        x: {
                            ticks: {
                                color: '#999',
                                maxRotation: 45,
                                minRotation: 45,
                                font: { size: 10 }
                            },
                            grid: {
                                color: '#2a2a2a'
                            }
                        },
                        y: {
                            ticks: {
                                color: '#4a90e2'
                            },
                            grid: {
                                color: '#2a2a2a'
                            }
                        }
                    }
                }
            });

            const ctx2 = document.getElementById('precipChart').getContext('2d');
            
            if (precipChart) {
                precipChart.destroy();
            }

            precipChart = new Chart(ctx2, {
                type: 'bar',
                data: {
                    labels: hours,
                    datasets: [
                        {
                            label: 'Precip Probability (%)',
                            data: precipProb,
                            backgroundColor: 'rgba(94, 189, 94, 0.6)',
                            borderColor: '#5ebd5e',
                            borderWidth: 1,
                            type: 'line',
                            tension: 0.4,
                            yAxisID: 'y'
                        },
                        {
                            label: 'Rain (in)',
                            data: rain,
                            backgroundColor: '#3498db',
                            yAxisID: 'y1'
                        },
                        {
                            label: 'Snow (in)',
                            data: snow,
                            backgroundColor: '#ecf0f1',
                            yAxisID: 'y1'
                        }
                    ]
                },
                options: {
                    responsive: true,
                    maintainAspectRatio: false,
                    interaction: {
                        mode: 'index',
                        intersect: false
                    },
                    plugins: {
                        legend: {
                            labels: {
                                color: '#e0e0e0',
                                font: { size: 12 }
                            }
                        }
                    },
                    scales: {
                        x: {
                            stacked: true,
                            ticks: {
                                color: '#999',
                                maxRotation: 45,
                                minRotation: 45,
                                font: { size: 10 }
                            },
                            grid: {
                                color: '#2a2a2a'
                            }
                        },
                        y: {
                            type: 'linear',
                            display: true,
                            position: 'left',
                            ticks: {
                                color: '#5ebd5e'
                            },
                            grid: {
                                color: '#2a2a2a'
                            },
                            title: {
                                display: true,
                                text: 'Probability (%)',
                                color: '#5ebd5e'
                            }
                        },
                        y1: {
                            type: 'linear',
                            display: true,
                            position: 'right',
                            stacked: true,
                            ticks: {
                                color: '#3498db'
                            },
                            grid: {
                                drawOnChartArea: false
                            },
                            title: {
                                display: true,
                                text: 'Amount (in)',
                                color: '#3498db'
                            }
                        }
                    }
                }
            });

            const ctx3 = document.getElementById('precipAccumChart').getContext('2d');
            
            if (precipAccumChart) {
                precipAccumChart.destroy();
            }

            let cumulativeRain = [];
            let cumulativeSnow = [];
            let cumulativeTotal = [];
            let sumRain = 0;
            let sumSnow = 0;
            let sumTotal = 0;

            for (let i = 0; i < timeRange; i++) {
                sumRain += rain[i] || 0;
                sumSnow += snow[i] || 0;
                sumTotal += totalPrecip[i] || 0;
                cumulativeRain.push(sumRain);
                cumulativeSnow.push(sumSnow);
                cumulativeTotal.push(sumTotal);
            }

            precipAccumChart = new Chart(ctx3, {
                type: 'line',
                data: {
                    labels: hours,
                    datasets: [
                        {
                            label: 'Total Accumulation (in)',
                            data: cumulativeTotal,
                            borderColor: '#9b59b6',
                            backgroundColor: 'rgba(155, 89, 182, 0.1)',
                            tension: 0.4,
                            borderWidth: 3,
                            fill: true
                        },
                        {
                            label: 'Rain Accumulation (in)',
                            data: cumulativeRain,
                            borderColor: '#3498db',
                            backgroundColor: 'rgba(52, 152, 219, 0.1)',
                            tension: 0.4,
                            borderWidth: 2,
                            fill: false
                        },
                        {
                            label: 'Snow Accumulation (in)',
                            data: cumulativeSnow,
                            borderColor: '#ffffff',
                            backgroundColor: 'rgba(255, 255, 255, 0.1)',
                            tension: 0.4,
                            borderWidth: 2,
                            fill: false
                        }
                    ]
                },
                options: {
                    responsive: true,
                    maintainAspectRatio: false,
                    interaction: {
                        mode: 'index',
                        intersect: false
                    },
                    plugins: {
                        legend: {
                            labels: {
                                color: '#e0e0e0',
                                font: { size: 12 }
                            }
                        }
                    },
                    scales: {
                        x: {
                            ticks: {
                                color: '#999',
                                maxRotation: 45,
                                minRotation: 45,
                                font: { size: 10 }
                            },
                            grid: {
                                color: '#2a2a2a'
                            }
                        },
                        y: {
                            ticks: {
                                color: '#9b59b6'
                            },
                            grid: {
                                color: '#2a2a2a'
                            },
                            title: {
                                display: true,
                                text: 'Accumulation (inches)',
                                color: '#9b59b6'
                            }
                        }
                    }
                }
            });

            const ctx4 = document.getElementById('windChart').getContext('2d');
            
            if (windChart) {
                windChart.destroy();
            }

            windChart = new Chart(ctx4, {
                type: 'line',
                data: {
                    labels: hours,
                    datasets: [
                        {
                            label: 'Wind Speed (mph)',
                            data: wind,
                            borderColor: '#f39c12',
                            backgroundColor: 'rgba(243, 156, 18, 0.1)',
                            tension: 0.4,
                            fill: true,
                            borderWidth: 2
                        }
                    ]
                },
                options: {
                    responsive: true,
                    maintainAspectRatio: false,
                    interaction: {
                        mode: 'index',
                        intersect: false
                    },
                    plugins: {
                        legend: {
                            labels: {
                                color: '#e0e0e0',
                                font: { size: 12 }
                            }
                        }
                    },
                    scales: {
                        x: {
                            ticks: {
                                color: '#999',
                                maxRotation: 45,
                                minRotation: 45,
                                font: { size: 10 }
                            },
                            grid: {
                                color: '#2a2a2a'
                            }
                        },
                        y: {
                            ticks: {
                                color: '#f39c12'
                            },
                            grid: {
                                color: '#2a2a2a'
                            }
                        }
                    }
                }
            });
        }

        function generateHistoricalChart(historicalData) {
            if (!historicalData || !historicalData.hourly) return;

            const ctx = document.getElementById('historicalChart').getContext('2d');
            
            if (historicalChart) {
                historicalChart.destroy();
            }

            const hours = historicalData.hourly.time.map(time => {
                const date = new Date(time);
                return date.toLocaleString('en-US', { month: 'short', day: 'numeric', hour: 'numeric' });
            });

            const temps = historicalData.hourly.temperature_2m || [];
            const wind = historicalData.hourly.wind_speed_10m || [];
            const rainHourly = historicalData.hourly.rain || [];
            const snowHourly = historicalData.hourly.snowfall || [];

            let cumulativeRain = [];
            let cumulativeSnow = [];
            let sumRain = 0;
            let sumSnow = 0;

            for (let i = 0; i < rainHourly.length; i++) {
                sumRain += rainHourly[i] || 0;
                sumSnow += snowHourly[i] || 0;
                cumulativeRain.push(sumRain);
                cumulativeSnow.push(sumSnow);
            }

            historicalChart = new Chart(ctx, {
                type: 'line',
                data: {
                    labels: hours,
                    datasets: [
                        {
                            label: 'Temperature (°F)',
                            data: temps,
                            borderColor: '#4a90e2',
                            backgroundColor: 'rgba(74, 144, 226, 0.1)',
                            tension: 0.4,
                            borderWidth: 2,
                            yAxisID: 'y',
                            fill: false
                        },
                        {
                            label: 'Wind (mph)',
                            data: wind,
                            borderColor: '#f39c12',
                            backgroundColor: 'rgba(243, 156, 18, 0.1)',
                            tension: 0.4,
                            borderWidth: 2,
                            yAxisID: 'y',
                            fill: false
                        },
                        {
                            label: 'Rain Accumulation (in)',
                            data: cumulativeRain,
                            borderColor: '#3498db',
                            backgroundColor: 'rgba(52, 152, 219, 0.1)',
                            tension: 0.4,
                            borderWidth: 2,
                            yAxisID: 'y1',
                            fill: true
                        },
                        {
                            label: 'Snow Accumulation (in)',
                            data: cumulativeSnow,
                            borderColor: '#ffffff',
                            backgroundColor: 'rgba(255, 255, 255, 0.1)',
                            tension: 0.4,
                            borderWidth: 2,
                            yAxisID: 'y1',
                            fill: true
                        }
                    ]
                },
                options: {
                    responsive: true,
                    maintainAspectRatio: false,
                    interaction: {
                        mode: 'index',
                        intersect: false
                    },
                    plugins: {
                        legend: {
                            labels: {
                                color: '#e0e0e0',
                                font: { size: 12 }
                            }
                        }
                    },
                    scales: {
                        x: {
                            ticks: {
                                color: '#999',
                                maxRotation: 45,
                                minRotation: 45,
                                font: { size: 10 }
                            },
                            grid: {
                                color: '#2a2a2a'
                            }
                        },
                        y: {
                            type: 'linear',
                            display: true,
                            position: 'left',
                            ticks: {
                                color: '#4a90e2'
                            },
                            grid: {
                                color: '#2a2a2a'
                            },
                            title: {
                                display: true,
                                text: 'Temp (°F) / Wind (mph)',
                                color: '#4a90e2'
                            }
                        },
                        y1: {
                            type: 'linear',
                            display: true,
                            position: 'right',
                            ticks: {
                                color: '#3498db'
                            },
                            grid: {
                                drawOnChartArea: false
                            },
                            title: {
                                display: true,
                                text: 'Accumulation (in)',
                                color: '#3498db'
                            }
                        }
                    }
                }
            });
        }

        function generateDailyForecasts(hourlyData, startIndex) {
            const now = new Date();
            const todayStart = new Date(now.getFullYear(), now.getMonth(), now.getDate());
            const tomorrowStart = new Date(todayStart);
            tomorrowStart.setDate(tomorrowStart.getDate() + 1);
            const dayAfterStart = new Date(todayStart);
            dayAfterStart.setDate(dayAfterStart.getDate() + 2);
            const dayAfterEnd = new Date(dayAfterStart);
            dayAfterEnd.setDate(dayAfterEnd.getDate() + 1);

            function getDayData(dayStart, dayEnd) {
                const dayIndices = [];
                for (let i = 0; i < hourlyData.time.length; i++) {
                    const time = new Date(hourlyData.time[i]);
                    if (time >= dayStart && time < dayEnd) {
                        dayIndices.push(i);
                    }
                }

                if (dayIndices.length === 0) return null;

                const dayTemps = dayIndices.map(i => hourlyData.temperature_2m[i]);
                const dayWind = dayIndices.map(i => hourlyData.wind_speed_10m[i]);
                const dayRain = dayIndices.map(i => hourlyData.rain?.[i] || 0);
                const daySnow = dayIndices.map(i => hourlyData.snowfall?.[i] || 0);

                return {
                    highTemp: Math.max(...dayTemps),
                    lowTemp: Math.min(...dayTemps),
                    highWind: Math.max(...dayWind),
                    lowWind: Math.min(...dayWind),
                    totalRain: dayRain.reduce((a, b) => a + b, 0),
                    totalSnow: daySnow.reduce((a, b) => a + b, 0)
                };
            }

            function formatDayForecast(data) {
                if (!data) return '<div class="daily-value">No data available</div>';
                
                return `
                    <div class="daily-stat">
                        <span class="daily-label">Low/High Temp:</span>
                        <span class="daily-value temp">${Math.round(data.lowTemp)}°F / ${Math.round(data.highTemp)}°F</span>
                    </div>
                    <div class="daily-stat">
                        <span class="daily-label">Wind Range:</span>
                        <span class="daily-value wind">${Math.round(data.lowWind)}-${Math.round(data.highWind)} mph</span>
                    </div>
                    <div class="daily-stat">
                        <span class="daily-label">Rain:</span>
                        <span class="daily-value rain">${data.totalRain.toFixed(2)}"</span>
                    </div>
                    <div class="daily-stat">
                        <span class="daily-label">Snow:</span>
                        <span class="daily-value snow">${data.totalSnow.toFixed(2)}"</span>
                    </div>
                `;
            }

            const todayData = getDayData(now, tomorrowStart);
            document.getElementById('todayForecast').innerHTML = formatDayForecast(todayData);

            const tomorrowData = getDayData(tomorrowStart, dayAfterStart);
            document.getElementById('tomorrowForecast').innerHTML = formatDayForecast(tomorrowData);

            const dayAfterData = getDayData(dayAfterStart, dayAfterEnd);
            document.getElementById('dayAfterForecast').innerHTML = formatDayForecast(dayAfterData);
        }

        function generateHourlyTable(hours, temps, feelsLike, precipProb, totalPrecip, rain, snow, wind) {
            let tableHTML = `
                <table class="hourly-table">
                    <thead>
                        <tr>
                            <th>Time</th>
                            <th>Temp</th>
                            <th>Feels Like</th>
                            <th>Precip %</th>
                            <th>Rain</th>
                            <th>Snow</th>
                            <th>Wind</th>
                        </tr>
                    </thead>
                    <tbody>
            `;

            for (let i = 0; i < hours.length; i++) {
                tableHTML += `
                    <tr>
                        <td>${hours[i]}</td>
                        <td class="temp-cell">${Math.round(temps[i])}°F</td>
                        <td class="temp-cell">${Math.round(feelsLike[i])}°F</td>
                        <td class="precip-cell">${Math.round(precipProb[i])}%</td>
                        <td class="rain-cell">${rain[i].toFixed(2)}"</td>
                        <td class="snow-cell">${snow[i].toFixed(2)}"</td>
                        <td class="wind-cell">${Math.round(wind[i])} mph</td>
                    </tr>
                `;
            }

            tableHTML += `
                    </tbody>
                </table>
            `;

            document.getElementById('hourlyTable').innerHTML = tableHTML;
        }

        function getWeatherDescription(code) {
            const codes = {
                0: 'Clear sky',
                1: 'Mainly clear',
                2: 'Partly cloudy',
                3: 'Overcast',
                45: 'Foggy',
                48: 'Depositing rime fog',
                51: 'Light drizzle',
                53: 'Moderate drizzle',
                55: 'Dense drizzle',
                61: 'Slight rain',
                63: 'Moderate rain',
                65: 'Heavy rain',
                71: 'Slight snow',
                73: 'Moderate snow',
                75: 'Heavy snow',
                77: 'Snow grains',
                80: 'Slight rain showers',
                81: 'Moderate rain showers',
                82: 'Violent rain showers',
                85: 'Slight snow showers',
                86: 'Heavy snow showers',
                95: 'Thunderstorm',
                96: 'Thunderstorm with slight hail',
                99: 'Thunderstorm with heavy hail'
            };
            return codes[code] || 'Unknown';
        }

        function showError(message) {
            const errorDiv = document.getElementById('error');
            errorDiv.textContent = message;
            errorDiv.classList.add('active');
        }

        window.addEventListener('load', () => {
            getForecast(28.2189, -82.4526);
        });
    </script>
<script>
  if ('serviceWorker' in navigator) {
    navigator.serviceWorker.register('/service-worker.js');
  }
</script>
</body>
</html>
